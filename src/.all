CONCAT_ID=##concat##
##concat##CHttp.cpp
#include <CHttp.h>
#include <CTcp.h>
#include <CUrl.h>
#include <CThrow.h>
#include <CStrUtil.h>
#include <cstdio>

namespace {

class Parser {
 public:
  Parser(const std::string &str) :
   str_(str), pos_(0), len_(str.size()) {
  }

  void skipSpace() {
    while (pos_ < len_ && isspace(str_[pos_]))
      ++pos_;
  }

  std::string readWord() {
    skipSpace();

    int j = pos_;

    while (pos_ < len_ && (isalnum(str_[pos_]) || str_[pos_] == '_'))
      ++pos_;

    std::string word = str_.substr(j, pos_ - j);

    return word;
  }

  int readInteger() {
    std::string word = readWord();

    if (! CStrUtil::isInteger(word))
      return -1;

    return CStrUtil::toInteger(word);
  }

  bool skipChar(char c) {
    skipSpace();

    if (pos_ >= len_ || str_[pos_] != c)
      return false;

    ++pos_;

    return true;
  }

 private:
  std::string str_;
  int         pos_ { 0 };
  int         len_ { 0 };
};

int monthNameToInt(const std::string &name) {
  typedef std::vector<std::string> Names;

  static Names months = {{ "jan", "feb", "mar", "apr", "may", "jun",
                           "jul", "aug", "sep", "oct", "nov", "dec" }};

  for (uint i = 0; i < months.size(); ++i)
    if (name == months[i])
      return i;

  return 0;
}

}

//---

CHttp::
CHttp(const std::string &url)
{
  url_ = new CUrl(url);
  tcp_ = new CTcp;
}

CHttp::
~CHttp()
{
  delete tcp_;
  delete url_;
}

void
CHttp::
setDebug(bool debug)
{
  debug_ = debug;
}

void
CHttp::
setTcpDebug(bool debug)
{
  tcp_->setDebug(debug);
}

bool
CHttp::
download(CHttpData &data)
{
  const std::string &site = url_->getSite();

  std::string file = url_->getFile();

  if (url_->getIsDir())
    file += "/";

  if (! tcp_->connect(site)) {
    std::cerr << "Connect failed" << std::endl;
    return false;
  }

  std::string message;

  message += "GET /" + file + " HTTP/1.1\r\n";
  message += "Host: " + site + "\r\n";
  message += "User-Agent: CWebGet/1.0\r\n";
  message += "Accept: text/html,text/plain,image/gif,image/jpg,image/png,*/*\r\n";
  message += "Accept-Language: en-us,en\r\n";
  message += "Accept-Charset: ISO-8859-1,utf-8\r\n";
  message += "\r\n";

  if (debug_)
    std::cerr << message << std::endl;

  if (! tcp_->write(message)) {
    std::cerr << "Write failed" << std::endl;
    return false;
  }

  if (! tcp_->read(data.data)) {
    std::cerr << "Read failed" << std::endl;
    return false;
  }

  std::string line;
  std::string name, value;

  data.data = CStrUtil::readLine(data.data, line);

  line = CStrUtil::stripSpaces(line);

  if (debug_)
    std::cerr << line << std::endl;

  relocated_   = false;
  newLocation_ = "";

  std::vector<std::string> words;

  CStrUtil::addWords(line, words);

  if (words.size() >= 2) {
    int error_code = CStrUtil::toInteger(words[1]);

    if      (error_code == 200)
      ;
    else if (error_code == 301)
      relocated_ = true;
    else if (error_code == 302)
      relocated_ = true;
    else if (error_code == 400)
      return false;
    else if (error_code == 404)
      return false;
    else
      std::cerr << "Unrecognised reply \'" << line << std::endl;
  }
  else
    std::cerr << "Unrecognised reply \'" << line << std::endl;

  data.data = readLine(data.data, line);

  int data_length = 0;

  chunked_ = false;

  while (line.size() > 0) {
    decodeLine(line, name, value);

    if (debug_)
      std::cerr << name << ":" << value << std::endl;

    if      (name == "Transfer-Encoding") {
      if (value == "chunked")
        chunked_ = true;
    }
    else if (name == "Content-Type") {
      decodeContent(value, data.type, data.sub_type);
    }
    else if (name == "Content-Length") {
      data_length = CStrUtil::toInteger(value);
    }
    else if (name == "Location") {
      newLocation_ = value;
    }
    else if (name == "Last-Modified") {
      decodeDate(value, lastModified_);
    }

    data.data = readLine(data.data, line);
  }

  if (relocated_) {
    if (newLocation_ != "") {
      std::cerr << "Moved to " << newLocation_ << std::endl;
      return true;
    }
    else {
      std::cerr << "Moved to unspecified location" << std::endl;
      return false;
    }
  }

  if (chunked_) {
    if (debug_)
      std::cerr << "Chunked" << std::endl;

    std::string data1;

    if (data.data.size() == 0) {
      if (! getMoreData(site, data.data))
        return false;
    }

    data.data = readLine(data.data, line);

    uint len;

    if (sscanf(line.c_str(), "%x", &len) != 1)
      len = 0;

    if (debug_)
      std::cerr << line << "=" << len << std::endl;

    while (len > 0) {
      while (data.data.size() < len) {
        data1 += data.data;

        len -= data.data.size();

        if (! getMoreData(site, data.data))
          return false;
      }

      if (data.data.size() >= len) {
        data1 += data.data.substr(0, len);

        data.data = data.data.substr(len);
      }

      if (data.data.size() == 0) {
        if (! getMoreData(site, data.data))
          return false;
      }

      data.data = readLine(data.data, line);

      if (data.data.size() == 0) {
        if (! getMoreData(site, data.data))
          return false;
      }

      data.data = readLine(data.data, line);

      if (sscanf(line.c_str(), "%x", &len) != 1)
        len = 0;

      if (debug_)
        std::cerr << line << "=" << len << std::endl;
    }

    data.data = data1;
  }
  else {
    std::string more_data;

    int data_length1 = data_length;

    data_length1 -= data.data.size();

    while (data_length1 > 0) {
      if (! getMoreData(site, more_data, data_length1))
        return false;

      int more_len = more_data.size();

      if (more_len == 0)
        break;

      data_length1 -= more_len;

      data.data += more_data;
    }

    if (data_length1 != 0) {
      std::cerr << "Short Read (" << (data_length - data_length1) << " of " <<
                   data_length << ")" << std::endl;
      return true;
    }
  }

  return true;
}

bool
CHttp::
getMoreData(const std::string &, std::string &more_data)
{
  if (! tcp_->read(more_data)) {
    std::cerr << "Read failed" << std::endl;
    return false;
  }

  return true;
}

bool
CHttp::
getMoreData(const std::string &, std::string &more_data, int len)
{
  if (! tcp_->read(more_data, len)) {
    std::cerr << "Read failed" << std::endl;
    return false;
  }

  return true;
}

std::string
CHttp::
readLine(const std::string &data, std::string &line)
{
  std::string data1 = CStrUtil::readLine(data, line);

  int len = line.size();

  if (line[len - 1] == '\r')
    line = line.substr(0, len - 1);

  if (debug_)
    std::cerr << "'" << line << "'" << std::endl;

  return data1;
}

void
CHttp::
decodeLine(const std::string &line, std::string &name, std::string &value)
{
  std::string::size_type pos = line.find(':');

  if (pos == std::string::npos) {
    name  = "";
    value = "";
    return;
  }

  name  = line.substr(0, pos);
  value = line.substr(pos + 1);

  name  = CStrUtil::stripSpaces(name);
  value = CStrUtil::stripSpaces(value);
}

void
CHttp::
decodeContent(const std::string &value, std::string &type, std::string &sub_type)
{
  std::string::size_type pos = value.find('/');

  if (pos == std::string::npos)
    return;

  type     = value.substr(0, pos);
  sub_type = value.substr(pos + 1);

  type     = CStrUtil::stripSpaces(type);
  sub_type = CStrUtil::stripSpaces(sub_type);
}

bool
CHttp::
decodeDate(const std::string &value, time_t &t)
{
  Parser parser(value);

  std::string dayName = parser.readWord();

  parser.skipChar(',');

  int dayNum   = parser.readInteger();
  int monthNum = monthNameToInt(CStrUtil::toLower(parser.readWord()));
  int yearNum  = parser.readInteger();

  int hourNum = parser.readInteger();
  parser.skipChar(':');
  int minNum  = parser.readInteger();
  parser.skipChar(':');
  int secNum  = parser.readInteger();

  (void) parser.readWord(); // GMT

  //---

  struct tm tm;

  tm.tm_year  = yearNum - 1900;
  tm.tm_mon   = monthNum;
  tm.tm_mday  = dayNum;
  tm.tm_hour  = hourNum;
  tm.tm_min   = minNum;
  tm.tm_sec   = secNum;
  tm.tm_wday  = 0;
  tm.tm_yday  = 0;
  tm.tm_isdst = -1; // auto DST

  t = mktime(&tm);

  //---

  return true;
}
##concat##CTcp.cpp
#include <CTcp.h>
#include <COSRead.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <cerrno>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <unistd.h>

#define CTCP_WRITE_WAIT 5
#define CTCP_READ_WAIT  5

CTcp::
CTcp()
{
}

CTcp::
~CTcp()
{
  close();
}

void
CTcp::
setDebug(bool debug)
{
  debug_ = debug;
}

bool
CTcp::
connect(const std::string &hostname, ushort port /* 80 */)
{
  if (! inetConnect(hostname, port))
    return false;

  return true;
}

bool
CTcp::
getc(char *c)
{
  static char  read_buffer3[CTCP_READ_BUFFER_SIZE + 1];
  static uint  read_buffer3_len;
  static char *read_buffer3_ptr;

  if (read_buffer3_len > 0) {
    --read_buffer3_len;

    *c = *read_buffer3_ptr++;

    return true;
  }

  int num_read = 0;

  while (true) {
    if (! COSRead::wait_read(tcp_socket_, CTCP_READ_WAIT))
      break;

    num_read = ::read(tcp_socket_, read_buffer3, CTCP_READ_BUFFER_SIZE);

    if (num_read == -1 && errno == EINTR)
      continue;

    if (getDebug())
      std::cerr << "Read " << num_read << " bytes" << std::endl;

    if (num_read <= 0)
      break;

    read_buffer3_ptr = read_buffer3;
    read_buffer3_len = num_read;

    --read_buffer3_len;

    *c = *read_buffer3_ptr++;

    return true;
  }

  if (num_read < 0)
    return false;

  *c = '\0';

  return true;
}

bool
CTcp::
gets(std::string &str, int max_len)
{
  char c;

  while (true) {
    if (! getc(&c))
      return false;

    if (c == '\0')
      break;

    if (c == '\r')
      continue;

    if (c == '\n')
      break;

    str += c;

    if (max_len > 0 && (int) str.size() == max_len)
      return true;
  }

  return true;
}

bool
CTcp::
read(std::string &str)
{
  static char read_buffer1[CTCP_READ_BUFFER_SIZE + 1];

  str = "";

  int num_read   = 0;
  int total_read = 0;

  while (true) {
    if (! COSRead::wait_read(tcp_socket_, CTCP_READ_WAIT))
      break;

    num_read = ::read(tcp_socket_, read_buffer1, CTCP_READ_BUFFER_SIZE);

    if (num_read == -1 && errno == EINTR)
      continue;

    if (getDebug())
      std::cerr << "Read " << num_read << " bytes" << std::endl;

    if (num_read <= 0)
      break;

    read_buffer1[num_read] = '\0';

    str += std::string(read_buffer1, num_read);

    total_read += num_read;
  }

  if (getDebug())
    std::cerr << "Total " << total_read << " bytes" << std::endl;

  if (num_read < 0)
    return false;

  return true;
}

bool
CTcp::
read(std::string &str, uint len)
{
  static char *read_buffer2;
  static uint  read_buffer2_max;

  if (len > read_buffer2_max) {
    delete [] read_buffer2;

    read_buffer2_max = len + 256;

    read_buffer2 = new char [read_buffer2_max];
  }

  str = "";

  int num_read   = 0;
  int total_read = 0;

  while (true) {
    if (! COSRead::wait_read(tcp_socket_, CTCP_READ_WAIT))
      break;

    num_read = ::read(tcp_socket_, read_buffer2, len);

    if (num_read == -1 && errno == EINTR)
      continue;

    if (getDebug())
      std::cerr << "Read " << num_read << " bytes" << std::endl;

    if (num_read <= 0)
      break;

    read_buffer2[num_read] = '\0';

    str += std::string(read_buffer2, num_read);

    total_read += num_read;

    len -= num_read;

    if (len <= 0)
      break;
  }

  if (getDebug())
    std::cerr << "Total " << total_read << " bytes" << std::endl;

  if (num_read < 0)
    return false;

  return true;
}

bool
CTcp::
write(const std::string &str)
{
  int num_written = 0;

  int pos = 0;
  int len = str.size();

  const char *p = str.c_str();

  while (len > 0) {
    if (! COSRead::wait_write(tcp_socket_, CTCP_WRITE_WAIT))
      break;

    num_written = ::write(tcp_socket_, &p[pos], len);

    if (num_written == -1 && errno == EINTR)
      continue;

    if (getDebug())
      std::cerr << "Wrote " << num_written << " bytes" << std::endl;

    if (num_written <= 0)
      break;

    pos += num_written;
    len -= num_written;
  }

  if (len > 0)
    return false;

  return true;
}

bool
CTcp::
putc(char c)
{
  int num_written;

  bool written = false;

  while (! written) {
    if (! COSRead::wait_write(tcp_socket_, CTCP_WRITE_WAIT))
      break;

    num_written = ::write(tcp_socket_, &c, 1);

    if (num_written == -1 && errno == EINTR)
      continue;

    if (getDebug())
      std::cerr << "Wrote " << num_written << " bytes" << std::endl;

    if (num_written <= 0)
      break;

    written = true;
  }

  if (! written)
    return false;

  return true;
}

bool
CTcp::
close()
{
  if (tcp_socket_ != -1)
    ::close(tcp_socket_);

  tcp_socket_ = -1;

  return true;
}

bool
CTcp::
inetConnect(const std::string &hostname, ushort port)
{
#if 0
  // open socket
  tcp_socket_ = ::socket(AF_INET, SOCK_STREAM, 0);

  if (tcp_socket_ == -1) {
    perror("socket");
    return false;
  }

  //----

  // get host
  ulong addr = (ulong) inet_addr(hostname.c_str());

  struct hostent *hostent;

  if ((int) addr != -1)
    hostent = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);
  else
    hostent = gethostbyname(hostname.c_str());

  if (! hostent) {
    std::cerr << "gethostbyname failed for " << hostname << " : " <<
                 hstrerror(h_errno) << std::endl;
    return false;
  }

  if (getDebug()) {
    std::cerr << "host name : " << hostent->h_name << std::endl;

    std::cerr << "  aliases :";

    for (char **pp = hostent->h_aliases; *pp != NULL; pp++)
      std::cerr << " " << *pp;

    std::cerr << std::endl;
  }

  //----

  // connect
  for (char **pp = hostent->h_addr_list; *pp != NULL; pp++) {
    struct sockaddr_in sockaddr;

    memset(&sockaddr, 0, sizeof(struct sockaddr_in));

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(port);

    memcpy(&sockaddr.sin_addr, *pp, hostent->h_length);

    if (::connect(tcp_socket_, (struct sockaddr *) &sockaddr, sizeof(sockaddr)) != -1)
      return true;
  }

  return false;
#else
  // lookup hosts which will accept out connection
  char portStr[32];

  sprintf(portStr, "%d", port);

  struct addrinfo hints;

  memset(&hints, 0, sizeof(struct addrinfo));

  hints.ai_canonname = NULL;
  hints.ai_addr      = NULL;
  hints.ai_next      = NULL;
  hints.ai_family    = AF_UNSPEC /*AF_INET, AF_INET6*/;
  hints.ai_socktype  = SOCK_STREAM /*can we use SOCK_DGRAM*/;

  struct addrinfo *result;

  int rc = getaddrinfo(hostname.c_str(), portStr, &hints, &result);

  if (rc != 0) {
    std::cerr << gai_strerror(rc) << std::endl;
    return false;
  }

  // loop through hosts and try to connect to each one
  for (struct addrinfo *rp = result; rp != NULL; rp = rp->ai_next) {
    tcp_socket_ = ::socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);

    // try next
    if (tcp_socket_ == -1)
      continue;

    // success
    if (::connect(tcp_socket_, rp->ai_addr, rp->ai_addrlen) != -1) {
      if (getDebug()) {
        char host[NI_MAXHOST], service[NI_MAXSERV];

        int rc = getnameinfo(rp->ai_addr, rp->ai_addrlen, host, NI_MAXHOST,
                             service, NI_MAXSERV, NI_NUMERICSERV);

        if (rc != -1)
          std::cerr << "connected to " << host << ":" << service << std::endl;
      }

      break;
    }

    // failed
    ::close(tcp_socket_);

    tcp_socket_ = -1;
  }

  freeaddrinfo(result);

  if (tcp_socket_ == -1)
    return false;

  return true;
#endif
}
##concat##CUrl.cpp
#include <CUrl.h>
#include <COSFile.h>
#include <CFile.h>
#include <CStrUtil.h>

std::string CUrl::current_site_ = ".";

CUrl::
CUrl()
{
}

CUrl::
CUrl(const CFile &file)
{
  url_ = "file://" + file.getPath();

  decode();
}

CUrl::
CUrl(const std::string &url) :
 url_(url)
{
  decode();
}

bool
CUrl::
getSearch(const std::string &name, bool *value) const
{
  std::string value1;

  if (! getSearch(name, value1))
    return false;

  if (! CStrUtil::toBool(value1, value))
    return false;

  return true;
}

bool
CUrl::
getSearch(const std::string &name, int *value) const
{
  std::string value1;

  if (! getSearch(name, value1))
    return false;

  if (! CStrUtil::toInteger(value1, value))
    return false;

  return true;
}

bool
CUrl::
getSearch(const std::string &name, double *value) const
{
  std::string value1;

  if (! getSearch(name, value1))
    return false;

  if (! CStrUtil::toReal(value1, value))
    return false;

  return true;
}

bool
CUrl::
getSearch(const std::string &name, std::string &value) const
{
  SearchList::const_iterator p = searches_.find(name);

  if (p == searches_.end())
    return false;

  value = (*p).second;

  return true;
}

void
CUrl::
setSearch(const std::string &name, bool value)
{
  setSearch(name, CStrUtil::toString(value));
}

void
CUrl::
setSearch(const std::string &name, int value)
{
  setSearch(name, CStrUtil::toString(value));
}

void
CUrl::
setSearch(const std::string &name, double value)
{
  setSearch(name, CStrUtil::toString(value));
}

void
CUrl::
setSearch(const std::string &name, const std::string &value)
{
  SearchList::iterator p = searches_.find(name);

  if (p == searches_.end())
    searches_[name] = value;
  else
    (*p).second = value;;
}

void
CUrl::
decode()
{
  std::string url1 = url_;

  std::string::size_type pos;

  // Remove target

  pos = url1.rfind('#');

  if (pos != std::string::npos) {
    target_ = url1.substr(pos + 1);

    url1 = url1.substr(0, pos);
  }
  else
    target_ = "";

  //------

  // Remove searches

  pos = url1.rfind('?');

  if (pos != std::string::npos) {
    std::string search, name, value;

    std::string searches = url1.substr(pos + 1);

    url1 = url1.substr(0, pos);

    // split search into parts

    pos = searches.find('&');

    while (pos != std::string::npos) {
      search = searches.substr(0, pos);

      searches = searches.substr(pos + 1);

      pos = search.find('=');

      if (pos != std::string::npos) {
        name  = search.substr(0, pos);
        value = search.substr(pos + 1);
      }
      else {
        name  = search;
        value = "";
      }

      searches_[name] = value;

      pos = searches.find('&');
    }

    pos = searches.find('=');

    if (pos != std::string::npos) {
      name  = searches.substr(0, pos);
      value = searches.substr(pos + 1);
    }
    else {
      name  = searches;
      value = "";
    }

    searches_[name] = value;
  }

  //------

  // Remove extra trailing / on file name

  is_dir_ = false;

  int len = url1.size();

  while (len > 0 && url1[len - 1] == '/') {
    is_dir_ = true;

    url1 = url1.substr(0, len - 1);

    --len;
  }

  //------

  // Get prefix

  pos = url1.find(':');

  if (pos != std::string::npos) {
    setPrefix(url1.substr(0, pos));

    url1 = url1.substr(pos + 1);

    CStrUtil::toLower(getPrefix());
  }
  else
    setPrefix("");

  //----

  if      (isHttp()) {
    if (url1.size() > 0 && url1[0] == '/')
      url1 = url1.substr(1);

    if (url1.size() > 0 && url1[0] == '/')
      url1 = url1.substr(1);

    std::string::size_type file_separator_pos = url1.find('/');

    if (file_separator_pos != std::string::npos) {
      site_ = url1.substr(0, file_separator_pos);

      file_ = url1.substr(file_separator_pos + 1);
    }
    else {
      site_ = url1;

      file_ = "";
    }
  }
  else if (isFile()) {
    if (url1.size() > 0 && url1[0] == '/')
      url1 = url1.substr(1);

    if (url1.size() > 0 && url1[0] == '/')
      url1 = url1.substr(1);

    if      (current_site_ != ".")
      site_ = current_site_;
    else if (url1.size() > 0 && url1[0] == '/') {
      std::string::size_type pos = url1.rfind('/');

      site_ = url1.substr(0, pos);
      url1  = url1.substr(pos + 1);
    }
    else
      site_ = COSFile::getCurrentDir();

    file_ = url1;
  }
  else {
    if (getPrefix() == "") {
      if (current_site_ != ".") {
        setPrefix("http");

        if (url1.size() > 0 && url1[0] == '/')
          url1 = url1.substr(1);
      }
      else
        setPrefix("file");
    }

    if (current_site_ != ".")
      site_ = current_site_;
    else
      site_ = COSFile::getCurrentDir();

    file_ = url1;
  }

  //------

  file_ = encodeFile(file_);

  //------

  pos = file_.rfind('.');

  if (pos != std::string::npos)
    suffix_ = file_.substr(pos + 1);
  else
    suffix_ = "";

  suffix_ = CStrUtil::toLower(suffix_);

  full_url_ = getPrefix() + "://" + site_ + "/";

  if (file_ != "") {
    std::string::size_type file_separator_pos = file_.rfind('/');

    if (file_separator_pos != std::string::npos)
      local_file_ = file_.substr(file_separator_pos + 1);
    else
      local_file_ = file_;
  }
  else {
    local_file_ = "index.html";
  }

  full_url_ += local_file_;

  if (! searches_.empty()) {
    full_url_ += "?";

    SearchList::iterator p1 = searches_.begin();
    SearchList::iterator p2 = searches_.end  ();

    for (uint i = 0; p1 != p2; ++p1, ++i) {
      if (i > 0)
        full_url_ += '&';

      full_url_ += (*p1).first;

      if ((*p1).second != "")
        full_url_ += "=" + (*p1).second;
    }
  }

  if (target_ != "")
    full_url_ += "#" + target_;
}

std::string
CUrl::
encode() const
{
  std::string file = getFile();

  std::string file1 = encodeFile(file);

  std::string url_str = getPrefix() + "://" + getSite() + "/" + file1;

  if (getIsDir())
    url_str += "/";

  return url_str;
}

std::string
CUrl::
encodeFile(const std::string &file) const
{
  // Remove leading/trailing '/'
  std::string file1 = file;

  bool absolute = false;

  while (! file1.empty() && file1[0] == '/') {
    file1 = file1.substr(1);

    absolute = true;
  }

  while (! file1.empty() && file1[file1.size() - 1] == '/') {
    file1 = file1.substr(0, file1.size() - 1);
  }

  // split into parts
  std::vector<std::string> fields;

  CStrUtil::addFields(file1, fields, "/");

  if (fields.empty())
    return file;

  // Remove . and .. parts
  std::vector<std::string> fields1;

  for (uint i = 0; i < fields.size(); ++i) {
    if      (fields[i] == ".") {
      if (fields1.empty())
        return file;
    }
    else if (fields[i] == "..") {
      if (fields1.empty())
        return file;

      fields1.pop_back();
    }
    else
      fields1.push_back(fields[i]);
  }

  // rebuild filename
  std::string file2;

  if (absolute)
    file2 += "/";

  for (uint i = 0; i < fields1.size(); ++i) {
    if (! file2.empty() && file2[file2.size() - 1] != '/')
      file2 += "/";

    file2 += fields1[i];
  }

  return file2;
}

std::string
CUrl::
replaceSpecialChars(const std::string &str)
{
  std::string str1;

  uint len = str.size();

  for (uint i = 0; i < len; ++i) {
    if (str[i] == '%' && i < len - 2 &&
        isxdigit(str[i + 1]) && isxdigit(str[i + 2])) {
      uint hval;

      std::string hstr = str.substr(i + 1, 2);

      CStrUtil::decodeHexString(hstr, &hval);

      i += 2;

      str1 += char(hval);
    }
    else
      str1 += str[i];
  }

  return str1;
}

void
CUrl::
print() const
{
  print(std::cout);
}

void
CUrl::
print(std::ostream &os) const
{
  os << full_url_ << std::endl;
}

void
CUrl::
setCurrentSite(const CUrl &url)
{
  setCurrentSite(url.getSite());
}
##concat##CWebGet.cpp
#include <CWebGet.h>
#include <CDir.h>
#include <CFile.h>
#include <CHtmlLib.h>
#include <CStrUtil.h>
#include <CHttp.h>
#include <CImageLib.h>
#include <CFileUtil.h>
#include <CUrl.h>
#include <CThrow.h>
#include <CThread.h>

class CWebGetLoadPageProc : public CThreadArrayProc {
 private:
  CWebGetUrl *web_url_;

 public:
  CWebGetLoadPageProc(CThreadArray *array, CWebGetUrl *web_url_) :
   CThreadArrayProc(array), web_url_(web_url_) {
  }

  void *execute();

  bool getProcess() const { return web_url_->getProcess(); }
};

CWebGet::
CWebGet(const std::string &str) :
 base_url_(str)
{
  init();
}

CWebGet::
CWebGet(const CUrl &url) :
 base_url_(url)
{
  init();
}

void
CWebGet::
init()
{
  base_dir_ = CDir::getCurrent();

  addSite(base_url_);

  CUrl::setCurrentSite(base_url_);

  thread_array_ = new CThreadArray(10);
  mutex_        = new CThreadMutex();
}

CWebGet::
~CWebGet()
{
  delete thread_array_;
  delete mutex_;
}

void
CWebGet::
setDebug(bool debug)
{
  debug_ = debug;
}

void
CWebGet::
setHttpDebug(bool debug)
{
  http_debug_ = debug;
}

void
CWebGet::
setTcpDebug(bool debug)
{
  tcp_debug_ = debug;
}

void
CWebGet::
setOverwrite(bool overwrite)
{
  overwrite_ = overwrite;
}

void
CWebGet::
setListRefs(bool list_refs)
{
  list_refs_   = list_refs;
  use_threads_ = false;
}

void
CWebGet::
setUseThreads(bool use_threads)
{
  use_threads_ = use_threads;
  list_refs_   = false;
}

void
CWebGet::
addSite(const CUrl &url)
{
  addSite(url.getSite());
}

void
CWebGet::
addSite(const std::string &site)
{
  sites_.push_back(site);
}

void
CWebGet::
loadSubPage(CWebGetUrl &web_url)
{
  if (list_refs_)
    listRef(web_url);
  else
    tryLoadPage(web_url);
}

bool
CWebGet::
tryLoadPage(CWebGetUrl &web_url)
{
  try {
    loadPage(web_url);

    return true;
  }
  catch (...) {
    return false;
  }
}

bool
CWebGet::
loadPage(CWebGetUrl &web_url)
{
  if (! isValidSite(web_url))
    return false;

  web_url.setCurrentSite();

  if (isLoaded(web_url))
    return true;

  setLoaded(web_url);

  std::string base_dir = web_url.getBaseDir();

  if (isHigherDir(base_dir)) {
    std::cerr << "Skipping Higher Directory " << base_dir << std::endl;
    return true;
  }

  std::cout << "Loading Page '" << web_url.getUrlStr() << "'" << std::endl;

  if (debug_)
    std::cerr << "Output File '" << web_url.getFilename() << "'" << std::endl;

  if (! getPage(web_url))
    return false;

  CFile *file = web_url.getFile();

  file->close();

  return true;
}

bool
CWebGet::
getPage(CWebGetUrl &web_url)
{
  if (isSkipDownload(web_url))
    return false;

  CFile *file = web_url.getFile();

  web_url.setProcess(true);

  if (overwrite_ || ! file->exists()) {
    if (use_threads_)
      mutex_->lock();

    CDir::makeDirs(*file);

    std::string path = file->getDir();

    CDir::enter(path);

    if (debug_)
      std::cerr << "Dir " << CDir::getCurrent() << std::endl;

    file->open(CFileBase::Mode::WRITE);

    CDir::leave();

    if (debug_)
      std::cerr << "Dir " << CDir::getCurrent() << std::endl;

    if (use_threads_)
      mutex_->unlock();

    //------

    if (! download(web_url, file))
      return false;
  }

  return true;
}

bool
CWebGet::
download(CWebGetUrl &web_url, CFile *file)
{
  if (debug_)
    std::cerr << "Downloading " << web_url.getUrlStr() << std::endl;

  if (use_threads_)
    mutex_->lock();

  CHttp http(web_url.getUrlStr());

  http.setDebug   (http_debug_);
  http.setTcpDebug(tcp_debug_);

  CHttpData data;

  bool flag = http.download(data);

  if (flag && ! http.isRelocated()) {
    file->write(data.data);

    if (! data.isHtmlData())
      web_url.setProcess(false);
  }

  if (use_threads_)
    mutex_->unlock();

  if (flag && http.isRelocated()) {
    std::string new_location = http.getNewLocation();

    if (debug_)
      std::cerr << "Redirected to " << new_location << std::endl;

    if (new_location == web_url.getUrlStr()) {
      std::cerr << "New location same as old location" << std::endl;
      return false;
    }

    CUrl url(new_location);

    CWebGetUrl web_url1(web_url.getWebGet(), url);

    flag = getPage(web_url1);
  }

  if (! flag) {
    CFile file(".error_data");

    file.write(data.data);
  }

  return flag;
}

bool
CWebGet::
processFile(CWebGetUrl &web_url)
{
  WebUrlList web_urls;

  if (! getWebUrls(web_url, web_urls))
    return false;

  uint num_web_urls = web_urls.size();

  CWebGetLoadPageProc **procs = NULL;

  if (use_threads_)
    procs = new CWebGetLoadPageProc * [num_web_urls];

  for (uint i = 0; i < num_web_urls; ++i) {
    if (! isValidSite(*web_urls[i]))
      continue;

    if (use_threads_) {
      if (isLoaded(*web_urls[i]))
        continue;

      procs[i] = new CWebGetLoadPageProc(thread_array_, web_urls[i]);

      thread_array_->startThread(procs[i]);
    }
    else
      loadSubPage(*web_urls[i]);
  }

  if (use_threads_)
    thread_array_->join(NULL);

  for (uint i = 0; i < num_web_urls; ++i) {
    if (web_urls[i]->getProcess())
      processFile(*web_urls[i]);
  }

  for (uint i = 0; i < num_web_urls; ++i) {
    if (use_threads_)
      delete procs[i];

    delete web_urls[i];
  }

  if (use_threads_)
    delete [] procs;

  return true;
}

bool
CWebGet::
getWebUrls(CWebGetUrl &web_url, WebUrlList &web_urls)
{
  if (! isHtmlFile(web_url))
    return false;

  CFile *file = web_url.getFile();

  std::string path = file->getDir();

  if (debug_)
    std::cerr << "Read Html File " << file->getName() << std::endl;

  CDir::enter(path);

  if (debug_)
    std::cerr << "Dir " << CDir::getCurrent() << std::endl;

  CHtml html;

  CHtmlParser parser(html);

  CHtmlParserTokens tokens;

  if (! parser.read(file->getName(), tokens)) {
    CDir::leave();

    if (debug_)
      std::cerr << "Dir " << CDir::getCurrent() << std::endl;

    return false;
  }

  WebUrlMap web_url_map;

  uint num_tokens = tokens.size();

  for (uint i = 0; i < num_tokens; ++i) {
    if (! tokens[i]->isTag())
      continue;

    CHtmlTag *tag = tokens[i]->getTag();

    const CHtmlTagDef &tag_def = tag->getTagDef();

    CHtmlTagId id = tag_def.getId();

    if (id != CHtmlTagId::A     &&
        id != CHtmlTagId::BODY  &&
        id != CHtmlTagId::IMG   &&
        id != CHtmlTagId::FRAME)
      continue;

    const CHtmlTagOptionArray &options = tag->getOptions();

    int num_options = (int) options.size();

    for (int j = 0; j < num_options; j++) {
      CHtmlTagOption *option = options[j];

      std::string option_name = option->getName();

      if ((id == CHtmlTagId::A     && CStrUtil::casecmp(option_name, "href"      ) == 0) ||
          (id == CHtmlTagId::BODY  && CStrUtil::casecmp(option_name, "background") == 0) ||
          (id == CHtmlTagId::IMG   && CStrUtil::casecmp(option_name, "src"       ) == 0) ||
          (id == CHtmlTagId::FRAME && CStrUtil::casecmp(option_name, "src"       ) == 0)) {
        std::string option_value = option->getValue();

        std::string save_site = CUrl::getCurrentSite();

        std::string site = save_site;

        if (web_url.getUrl().getIsDir())
          site += "/" + web_url.getUrl().getFile();

        CUrl::setCurrentSite(site);

        if (debug_)
          std::cerr << option_value << std::endl;

        CUrl url(option_value);

        CWebGetUrl *web_url1 = new CWebGetUrl(this, CUrl(url.getFullUrl()));

        CUrl::setCurrentSite(save_site);

        if (web_url_map.find(web_url1->getUrlStr()) == web_url_map.end()) {
          web_urls.push_back(web_url1);

          web_url_map[web_url1->getUrlStr()] = web_url1;
        }
        else
          delete web_url1;
      }
    }
  }

  CDir::leave();

  if (debug_)
    std::cerr << "Dir " << CDir::getCurrent() << std::endl;

  return true;
}

void
CWebGet::
listRef(CWebGetUrl &web_url)
{
  if (! isValidSite(web_url))
    return;

  std::cerr << web_url.getUrlStr() << std::endl;

  return;
}

bool
CWebGet::
isValidSite(CWebGetUrl &web_url)
{
  const CUrl &url = web_url.getUrl();

  if (url.getPrefix() != "http" && url.getPrefix() != "https")
    return false;

  const std::string &site = url.getSite();

  for (int i = 0; i < (int) sites_.size(); i++) {
    if (sites_[i] == site)
      return true;
  }

  return false;
}

bool
CWebGet::
isHigherDir(const std::string &dir)
{
  int count1 = countDirLevels(base_dir_);
  int count2 = countDirLevels(dir);

  return count1 > count2;
}

bool
CWebGet::
countDirLevels(const std::string &dir)
{
  int len = dir.size();

  int count = 0;

  for (int i = 0; i < len; i++)
    if (dir[i] == '/')
      count++;

  return count;
}

bool
CWebGet::
isSkipDownload(CWebGetUrl &web_url)
{
  const CUrl &url = web_url.getUrl();

  const std::string &suffix = url.getSuffix();

  if (suffix == "mp3")
    return true;

  return false;
}

bool
CWebGet::
isLoaded(CWebGetUrl &web_url)
{
  if (use_threads_)
    mutex_->lock();

  bool flag = false;

  const std::string &url_str = web_url.getUrlStr();

  if (loaded_urls_.find(url_str) != loaded_urls_.end())
    flag = true;

  if (use_threads_)
    mutex_->unlock();

  return flag;
}

void
CWebGet::
setLoaded(CWebGetUrl &web_url)
{
  if (use_threads_)
    mutex_->lock();

  std::string url_str = web_url.getUrlStr();

  loaded_urls_[url_str]++;

  if (use_threads_)
    mutex_->unlock();
}

bool
CWebGet::
isHtmlFile(CWebGetUrl &web_url)
{
  const CUrl &url = web_url.getUrl();

  const std::string &suffix = url.getSuffix();

  if (suffix == "jpg"  || suffix == "jpeg" ||
      suffix == "gif"  || suffix == "mp3"  ||
      suffix == "png"  || suffix == "zip"  ||
      suffix == "tar"  || suffix == "gz"   ||
      suffix == "3dml" || suffix == "exe"  ||
      suffix == "bmf"  || suffix == "c"    ||
      suffix == "pdf"  || suffix == "xpm"  ||
      suffix == "xbm"  || suffix == "bmp"  ||
      suffix == "wav"  || suffix == "mov"  ||
      suffix == "tif"  || suffix == "mpg"  ||
      suffix == "inc"  || suffix == "tiff" ||
      suffix == "pov"  || suffix == "cpp"  ||
      suffix == "pl"   || suffix == "h"    ||
      suffix == "txt"  || suffix == "java" ||
      suffix == "f"    || suffix == "hpp"  ||
      suffix == "ppm"  || suffix == "ps"   ||
      suffix == "eps"  || suffix == "z"    ||
      suffix == "avi"  || suffix == "ma"   ||
      suffix == "rar")
    return false;

  CFile *file = web_url.getFile();

  if (CFileUtil::checkJPG(file) || CFileUtil::checkGIF(file))
    return false;

  return true;
}

//------

void *
CWebGetLoadPageProc::
execute()
{
  CWebGet *webget = web_url_->getWebGet();

  webget->loadSubPage(*web_url_);

  return NULL;
}

//------

CWebGetUrl::
CWebGetUrl(CWebGet *webget, const CUrl &url) :
 webget_(webget), url_(url)
{
  url_str_ = encodeUrl(url_);

  urlToFilename(url, filename_);

  file_ = new CFile(filename_);

  process_ = false;
}

CWebGetUrl::
~CWebGetUrl()
{
  delete file_;
}

std::string
CWebGetUrl::
getBaseDir() const
{
  std::string base_dir = webget_->getBaseDir() + "/" + url_.getFile();

  return base_dir;
}

std::string
CWebGetUrl::
encodeUrl(const CUrl &url)
{
  std::string url_str = url.getPrefix() + std::string("://") + url.getSite() + "/" + url.getFile();

  CStrWords word_list = CStrUtil::toFields(url_str, "/");

  CStrWords::iterator word_p1 = word_list.begin();
  CStrWords::iterator word_p2 = word_list.end  ();

  std::string url_str1;

  std::string word1 = (*word_p1).getWord();

  ++word_p1;

  for ( ; word_p1 != word_p2; ++word_p1) {
    std::string word2 = (*word_p1).getWord();

    if (word2 != ".." && word1 != "..") {
      if (url_str1 != "")
        url_str1 += "/";

      url_str1 += word1;
    }

    word1 = word2;
  }

  if (url_str1 != "")
    url_str1 += "/";

  url_str1 += word1;

  if (url.getIsDir())
    url_str1 += "/";

  return url_str1;
}

bool
CWebGetUrl::
urlToFilename(const CUrl &url, std::string &filename)
{
  filename = webget_->getBaseDir() + "/" + url.getFile();

  if (! url.getIsDir()) {
    CFile file(filename);

    if (file.exists() && file.isDirectory()) {
      if (filename[filename.size() - 1] != '/')
        filename += "/";

      filename += "index.html";

      CFile file1(filename);

      filename = file1.getPath();
    }
    else
      filename = file.getPath();
  }
  else {
    filename += "/dummy.html";

    CFile file(filename);

    filename = file.getPath();
  }

  return true;
}

void
CWebGetUrl::
setCurrentSite() const
{
  CUrl::setCurrentSite(url_.getSite());
}
##concat##Makefile
CC = g++
AR = ar
RM = rm

CDEBUG = -g

INC_DIR = ../include
OBJ_DIR = ../obj
LIB_DIR = ../lib

all: $(LIB_DIR)/libCWebGet.a

SRC = \
CWebGet.cpp \
CUrl.cpp \
CHttp.cpp \
CTcp.cpp \

OBJS = $(patsubst %.cpp,$(OBJ_DIR)/%.o,$(SRC))

CPPFLAGS = \
-std=c++14 \
-I$(INC_DIR) \
-I. \
-I../../CHtml/include \
-I../../CArgs/include \
-I../../CImageLib/include \
-I../../CFileUtil/include \
-I../../CFile/include \
-I../../CThread/include \
-I../../COS/include \
-I../../CRegExp/include \
-I../../CMath/include \
-I../../CStrUtil/include \
-I../../CUtil/include \

clean:
	$(RM) -f $(OBJ_DIR)/*.o
	$(RM) -f $(LIB_DIR)/libCWebGet.a

$(OBJS): $(OBJ_DIR)/%.o: %.cpp
	$(CC) -c $< -o $(OBJ_DIR)/$*.o $(CPPFLAGS)

.SUFFIXES: .cpp

$(LIB_DIR)/libCWebGet.a: $(OBJS)
	$(AR) crv $(LIB_DIR)/libCWebGet.a $(OBJS)

